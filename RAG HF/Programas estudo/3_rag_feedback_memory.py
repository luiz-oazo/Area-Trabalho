#!/usr/bin/env python3
"""
PROGRAMA 3: RAG COM FEEDBACK PERSISTENTE
Sistema RAG que aprende e LEMBRA das avalia√ß√µes do usu√°rio
Otimizado para MacBook - MEM√ìRIA PERMANENTE
"""

import pickle
import os
import faiss
import numpy as np
import json
from sentence_transformers import SentenceTransformer
from transformers import pipeline
from datetime import datetime
import sys

class SmartRAGWithMemory:
    def __init__(self, save_dir="./rag_system_mac"):
        self.save_dir = save_dir
        self.embedding_model = None
        self.index = None
        self.chunks = None
        self.metadata = None
        self.generator = None

        # Sistema de mem√≥ria persistente
        self.feedback_data = {}
        self.document_scores = {}
        self.query_history = []
        self.learning_stats = {
            "total_queries": 0,
            "avg_rating": 0.0,
            "best_documents": {},
            "worst_documents": {},
            "improvement_trend": []
        }

    def load_system(self):
        """Carrega o sistema RAG treinado."""
        print("üîÑ Carregando sistema RAG com mem√≥ria...")
        print(f"üìÅ Diret√≥rio: {os.path.abspath(self.save_dir)}")

        if not os.path.exists(self.save_dir):
            print(f"‚ùå Sistema n√£o encontrado em {self.save_dir}")
            print("Execute primeiro: python 1_rag_trainer.py")
            return False

        try:
            # Carrega componentes b√°sicos
            print("  üìê Carregando modelo de embedding...")
            self.embedding_model = SentenceTransformer(f"{self.save_dir}/embedding_model")

            print("  üîç Carregando √≠ndice Faiss...")
            self.index = faiss.read_index(f"{self.save_dir}/faiss_index.bin")

            print("  üìä Carregando dados...")
            with open(f"{self.save_dir}/rag_data.pkl", "rb") as f:
                data = pickle.load(f)
                self.chunks = data['chunks']
                self.metadata = data['metadata']

            print("  ü§ñ Carregando gerador de texto...")
            self.generator = pipeline(
                "text2text-generation",
                model="t5-small",
                max_length=200,
                do_sample=False
            )

            # CARREGA MEM√ìRIA PERSISTENTE
            self.load_persistent_memory()

            print("‚úÖ Sistema carregado com sucesso!")
            print(f"üìä {len(self.chunks)} chunks dispon√≠veis")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao carregar sistema: {e}")
            return False

    def load_persistent_memory(self):
        """Carrega TODA a mem√≥ria de feedback anterior."""
        try:
            feedback_file = f"{self.save_dir}/persistent_memory.json"

            if os.path.exists(feedback_file):
                print("  üß† Carregando mem√≥ria persistente...")
                with open(feedback_file, "r", encoding='utf-8') as f:
                    memory_data = json.load(f)

                    self.feedback_data = memory_data.get("feedback_data", {})
                    self.document_scores = memory_data.get("document_scores", {})
                    self.query_history = memory_data.get("query_history", [])
                    self.learning_stats = memory_data.get("learning_stats", {
                        "total_queries": 0,
                        "avg_rating": 0.0,
                        "best_documents": {},
                        "worst_documents": {},
                        "improvement_trend": []
                    })

                # Mostra estat√≠sticas da mem√≥ria carregada
                total_queries = len(self.query_history)
                docs_with_feedback = len(self.document_scores)

                print(f"  üìà Mem√≥ria carregada:")
                print(f"     üî¢ {total_queries} consultas anteriores")
                print(f"     üìö {docs_with_feedback} documentos com feedback")

                if total_queries > 0:
                    recent_ratings = [q['rating'] for q in self.query_history[-10:]]
                    if recent_ratings:
                        avg_recent = sum(recent_ratings) / len(recent_ratings)
                        print(f"     ‚≠ê M√©dia √∫ltimas consultas: {avg_recent:.1f}/5")

                # Mostra documentos mais bem avaliados
                if self.document_scores:
                    best_docs = self.get_best_documents(3)
                    if best_docs:
                        print(f"     üèÜ Melhores documentos:")
                        for doc_id, avg_score in best_docs:
                            title = self.metadata[int(doc_id)]['title']
                            print(f"        - {title}: {avg_score:.1f}/5")

                print("  ‚úÖ Mem√≥ria restaurada com sucesso!")

            else:
                print("  üìä Nenhuma mem√≥ria anterior - come√ßando do zero")
                self.create_empty_memory_file()

        except Exception as e:
            print(f"  ‚ö†Ô∏è Erro ao carregar mem√≥ria: {e}")
            print("  üîÑ Criando nova mem√≥ria...")
            self.create_empty_memory_file()

    def create_empty_memory_file(self):
        """Cria arquivo de mem√≥ria vazio."""
        try:
            empty_memory = {
                "feedback_data": {},
                "document_scores": {},
                "query_history": [],
                "learning_stats": {
                    "total_queries": 0,
                    "avg_rating": 0.0,
                    "best_documents": {},
                    "worst_documents": {},
                    "improvement_trend": []
                },
                "created_at": datetime.now().isoformat(),
                "version": "1.0"
            }

            with open(f"{self.save_dir}/persistent_memory.json", "w", encoding='utf-8') as f:
                json.dump(empty_memory, f, indent=2, ensure_ascii=False)

        except Exception as e:
            print(f"  ‚ö†Ô∏è Erro ao criar arquivo de mem√≥ria: {e}")

    def save_persistent_memory(self):
        """Salva TODA a mem√≥ria de forma persistente."""
        try:
            feedback_file = f"{self.save_dir}/persistent_memory.json"

            # Atualiza estat√≠sticas
            self.update_learning_stats()

            # Prepara dados completos para salvar
            memory_data = {
                "feedback_data": self.feedback_data,
                "document_scores": self.document_scores,
                "query_history": self.query_history,
                "learning_stats": self.learning_stats,
                "last_updated": datetime.now().isoformat(),
                "total_queries": len(self.query_history),
                "total_documents_with_feedback": len(self.document_scores),
                "version": "1.0"
            }

            # Salva com backup
            backup_file = f"{self.save_dir}/persistent_memory_backup.json"
            if os.path.exists(feedback_file):
                # Cria backup da vers√£o anterior
                os.rename(feedback_file, backup_file)

            # Salva nova vers√£o
            with open(feedback_file, "w", encoding='utf-8') as f:
                json.dump(memory_data, f, indent=2, ensure_ascii=False)

            # Remove backup se salvou com sucesso
            if os.path.exists(backup_file):
                os.remove(backup_file)

            return True

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao salvar mem√≥ria: {e}")
            # Restaura backup se houver erro
            backup_file = f"{self.save_dir}/persistent_memory_backup.json"
            if os.path.exists(backup_file):
                os.rename(backup_file, feedback_file)
            return False

    def update_learning_stats(self):
        """Atualiza estat√≠sticas de aprendizado."""
        if not self.query_history:
            return

        # Calcula m√©dia geral
        all_ratings = [q['rating'] for q in self.query_history]
        self.learning_stats["total_queries"] = len(all_ratings)
        self.learning_stats["avg_rating"] = sum(all_ratings) / len(all_ratings)

        # Calcula tend√™ncia de melhoria (√∫ltimas 10 vs primeiras 10)
        if len(all_ratings) >= 20:
            first_10 = sum(all_ratings[:10]) / 10
            last_10 = sum(all_ratings[-10:]) / 10
            improvement = last_10 - first_10
            self.learning_stats["improvement_trend"].append({
                "timestamp": datetime.now().isoformat(),
                "improvement": improvement,
                "first_10_avg": first_10,
                "last_10_avg": last_10
            })

        # Identifica melhores e piores documentos
        best_docs = self.get_best_documents(5)
        worst_docs = self.get_worst_documents(5)

        self.learning_stats["best_documents"] = {str(doc_id): score for doc_id, score in best_docs}
        self.learning_stats["worst_documents"] = {str(doc_id): score for doc_id, score in worst_docs}

    def get_best_documents(self, n=5):
        """Retorna os N melhores documentos por avalia√ß√£o."""
        doc_averages = []
        for doc_id, scores in self.document_scores.items():
            if len(scores) >= 2:  # Pelo menos 2 avalia√ß√µes
                avg_score = sum(scores) / len(scores)
                doc_averages.append((doc_id, avg_score))

        doc_averages.sort(key=lambda x: x[1], reverse=True)
        return doc_averages[:n]

    def get_worst_documents(self, n=5):
        """Retorna os N piores documentos por avalia√ß√£o."""
        doc_averages = []
        for doc_id, scores in self.document_scores.items():
            if len(scores) >= 2:  # Pelo menos 2 avalia√ß√µes
                avg_score = sum(scores) / len(scores)
                doc_averages.append((doc_id, avg_score))

        doc_averages.sort(key=lambda x: x[1])
        return doc_averages[:n]

    def calculate_smart_weight(self, chunk_id):
        """Calcula peso inteligente baseado no hist√≥rico completo."""
        chunk_str = str(chunk_id)

        if chunk_str in self.document_scores:
            scores = self.document_scores[chunk_str]
            if len(scores) >= 1:
                # Calcula m√©dia ponderada (avalia√ß√µes mais recentes t√™m peso maior)
                weighted_scores = []
                for i, score in enumerate(scores):
                    weight = 1.0 + (i * 0.1)  # Avalia√ß√µes mais recentes pesam mais
                    weighted_scores.append(score * weight)

                avg_score = sum(weighted_scores) / sum(1.0 + (i * 0.1) for i in range(len(scores)))

                # Converte para peso (1-5 -> 0.2-2.5)
                if avg_score >= 4.0:
                    return 2.5  # Documentos excelentes
                elif avg_score >= 3.5:
                    return 1.8  # Documentos bons
                elif avg_score >= 2.5:
                    return 1.0  # Documentos neutros
                elif avg_score >= 1.5:
                    return 0.6  # Documentos ruins
                else:
                    return 0.2  # Documentos muito ruins

        return 1.0  # Peso neutro para documentos sem feedback

    def search_with_memory(self, question, k=5):
        """Busca documentos usando TODA a mem√≥ria de feedback."""
        try:
            # Cria embedding da pergunta
            question_embedding = self.embedding_model.encode([question])
            question_embedding = np.array(question_embedding).astype('float32')

            # Busca mais documentos para ter op√ß√µes
            scores, indices = self.index.search(question_embedding, k*3)

            # Aplica pesos baseados na mem√≥ria completa
            weighted_results = []
            for i, idx in enumerate(indices[0]):
                if idx < len(self.chunks):
                    base_score = float(scores[0][i])
                    memory_weight = self.calculate_smart_weight(idx)
                    adjusted_score = base_score / memory_weight  # Menor score = melhor

                    # Calcula confian√ßa baseada no hist√≥rico
                    chunk_str = str(idx)
                    confidence = "üî•" if memory_weight > 2.0 else "üëç" if memory_weight > 1.2 else "‚ö†Ô∏è" if memory_weight < 0.8 else "üìä"

                    weighted_results.append({
                        'chunk_id': idx,
                        'text': self.chunks[idx],
                        'metadata': self.metadata[idx],
                        'base_score': base_score,
                        'memory_weight': memory_weight,
                        'adjusted_score': adjusted_score,
                        'confidence': confidence,
                        'feedback_count': len(self.document_scores.get(chunk_str, [])),
                        'rank': i + 1
                    })

            # Ordena por score ajustado e pega os melhores
            weighted_results.sort(key=lambda x: x['adjusted_score'])
            return weighted_results[:k]

        except Exception as e:
            print(f"‚ùå Erro na busca: {e}")
            return []

    def generate_memory_based_answer(self, question, context_docs):
        """Gera resposta priorizando documentos com melhor hist√≥rico."""
        try:
            # Ordena documentos por peso de mem√≥ria (melhores primeiro)
            sorted_docs = sorted(context_docs, key=lambda x: x['memory_weight'], reverse=True)

            # Cria contexto priorizando documentos bem avaliados
            context_parts = []
            for doc in sorted_docs[:3]:  # Usa os 3 melhores
                title = doc['metadata']['title']
                text = doc['text']
                confidence = doc['confidence']
                context_parts.append(f"Fonte {confidence} ({title}): {text}")

            context = "\n\n".join(context_parts)

            # Limita tamanho do contexto
            if len(context) > 1200:
                context = context[:1200] + "..."

            # Cria prompt otimizado baseado na mem√≥ria
            prompt = f"""Com base no contexto fornecido, responda a pergunta de forma clara e precisa.

Pergunta: {question}

Contexto (fontes verificadas):
{context}

Resposta detalhada:"""

            # Gera resposta
            response = self.generator(prompt, max_length=180, num_return_sequences=1)

            if response and len(response) > 0:
                answer = response[0]['generated_text']
                # Limpa a resposta
                if "Resposta detalhada:" in answer:
                    answer = answer.split("Resposta detalhada:")[-1].strip()
                elif "Resposta:" in answer:
                    answer = answer.split("Resposta:")[-1].strip()
                return answer
            else:
                return "N√£o consegui gerar uma resposta adequada com base na mem√≥ria atual."

        except Exception as e:
            print(f"‚ùå Erro ao gerar resposta: {e}")
            return f"Erro: {str(e)}"

    def record_persistent_feedback(self, question, answer, docs_used, rating):
        """Registra feedback de forma PERMANENTE."""
        try:
            # Cria registro da consulta
            query_record = {
                "id": f"query_{len(self.query_history)}",
                "question": question,
                "answer": answer,
                "rating": rating,
                "timestamp": datetime.now().isoformat(),
                "docs_used": [
                    {
                        "chunk_id": doc['chunk_id'],
                        "title": doc['metadata']['title'],
                        "memory_weight": doc['memory_weight'],
                        "confidence": doc['confidence']
                    } for doc in docs_used
                ]
            }
            self.query_history.append(query_record)

            # Atualiza scores dos documentos PERMANENTEMENTE
            for doc in docs_used:
                chunk_id = str(doc['chunk_id'])
                if chunk_id not in self.document_scores:
                    self.document_scores[chunk_id] = []

                self.document_scores[chunk_id].append(rating)

                # Mant√©m hist√≥rico mais longo (√∫ltimos 25 feedbacks)
                if len(self.document_scores[chunk_id]) > 25:
                    self.document_scores[chunk_id] = self.document_scores[chunk_id][-25:]

            # SALVA IMEDIATAMENTE na mem√≥ria persistente
            save_success = self.save_persistent_memory()

            if save_success:
                print("üíæ Feedback salvo permanentemente!")
            else:
                print("‚ö†Ô∏è Aviso: Erro ao salvar feedback")

            # Mostra estat√≠sticas atualizadas
            self.show_memory_stats(rating)

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao registrar feedback: {e}")

    def show_memory_stats(self, current_rating):
        """Mostra estat√≠sticas baseadas na mem√≥ria completa."""
        total_queries = len(self.query_history)

        if total_queries >= 1:
            print(f"\nüß† ESTAT√çSTICAS DA MEM√ìRIA:")
            print(f"   üìù Consulta atual: #{total_queries}")
            print(f"   ‚≠ê Nota atual: {current_rating}/5")

            # M√©dia geral
            all_ratings = [q['rating'] for q in self.query_history]
            avg_all = sum(all_ratings) / len(all_ratings)
            print(f"   üìä M√©dia geral: {avg_all:.1f}/5")

            # √öltimas consultas
            if total_queries > 1:
                recent_count = min(5, total_queries)
                recent_ratings = all_ratings[-recent_count:]
                avg_recent = sum(recent_ratings) / len(recent_ratings)
                print(f"   üìà M√©dia √∫ltimas {recent_count}: {avg_recent:.1f}/5")

            # Documentos com feedback
            docs_with_feedback = len(self.document_scores)
            print(f"   üìö Documentos treinados: {docs_with_feedback}")

            # Tend√™ncia de melhoria
            if total_queries >= 10:
                first_5 = sum(all_ratings[:5]) / 5
                last_5 = sum(all_ratings[-5:]) / 5
                improvement = last_5 - first_5
                trend_emoji = "üìà" if improvement > 0.2 else "üìä" if improvement > -0.2 else "üìâ"
                print(f"   {trend_emoji} Tend√™ncia: {improvement:+.1f} pontos")

            # Feedback motivacional baseado na mem√≥ria
            if current_rating >= 4:
                print("   üéâ Excelente! A mem√≥ria est√° sendo atualizada.")
            elif current_rating >= 3:
                print("   üëç Boa resposta. Sistema aprendendo continuamente.")
            else:
                print("   üîÑ Resposta ruim. Ajustando mem√≥ria para melhorar.")

    def query_with_memory(self, question):
        """Executa consulta usando TODA a mem√≥ria de feedback."""
        print("\n" + "="*60)
        print("üîç PROCESSANDO COM MEM√ìRIA COMPLETA")
        print("="*60)
        print(f"‚ùì Pergunta: {question}")

        # Busca documentos usando mem√≥ria
        print("\nüß† Buscando com base na mem√≥ria de feedback...")
        docs = self.search_with_memory(question, k=5)

        if not docs:
            print("‚ùå Nenhum documento relevante encontrado.")
            return "Desculpe, n√£o encontrei informa√ß√µes relevantes.", []

        # Mostra documentos selecionados com informa√ß√µes de mem√≥ria
        print(f"\nüìã DOCUMENTOS SELECIONADOS (baseado na mem√≥ria):")
        for i, doc in enumerate(docs[:3], 1):
            print(f"  {i}. {doc['metadata']['title']} {doc['confidence']}")
            print(f"     Peso mem√≥ria: {doc['memory_weight']:.2f} | Feedbacks: {doc['feedback_count']}")
            print(f"     Score: {doc['base_score']:.3f} ‚Üí {doc['adjusted_score']:.3f}")
            print(f"     Texto: {doc['text'][:80]}...")
            print()

        # Gera resposta baseada na mem√≥ria
        print("ü§ñ Gerando resposta baseada na mem√≥ria...")
        answer = self.generate_memory_based_answer(question, docs)

        return answer, docs[:3]

    def interactive_memory_mode(self):
        """Modo interativo com mem√≥ria persistente completa."""
        print("üöÄ RAG COM MEM√ìRIA PERSISTENTE")
        print("="*60)
        print("üß† Este sistema LEMBRA de todas suas avalia√ß√µes!")
        print("üíæ Feedback √© salvo permanentemente")
        print("üìä Notas: 1-2 = Ruim | 3 = OK | 4-5 = Excelente")
        print("‚å®Ô∏è  Digite 'sair' para terminar")

        # Mostra estat√≠sticas da mem√≥ria carregada
        if self.query_history:
            total = len(self.query_history)
            avg = sum(q['rating'] for q in self.query_history) / total
            print(f"üîÑ Mem√≥ria carregada: {total} consultas anteriores (m√©dia: {avg:.1f}/5)")

        print("="*60)

        session_queries = 0

        while True:
            try:
                print("\n" + "üéØ" + "="*58)
                question = input("‚ùì Sua pergunta: ").strip()

                if question.lower() in ['sair', 'exit', 'quit', '']:
                    self.show_session_summary(session_queries)
                    break

                if len(question) < 3:
                    print("‚ö†Ô∏è  Pergunta muito curta. Tente novamente.")
                    continue

                # Processa pergunta com mem√≥ria
                answer, docs_used = self.query_with_memory(question)

                # Mostra resposta
                print("\nü§ñ RESPOSTA (baseada na mem√≥ria):")
                print("-" * 60)
                print(answer)
                print("-" * 60)

                # Solicita avalia√ß√£o
                print("\n‚≠ê AVALIE A RESPOSTA (ser√° salva permanentemente):")
                print("1 = Muito ruim | 2 = Ruim | 3 = OK | 4 = Boa | 5 = Excelente")

                while True:
                    try:
                        rating_input = input("Sua nota (1-5): ").strip()
                        rating = int(rating_input)
                        if 1 <= rating <= 5:
                            break
                        else:
                            print("Por favor, digite um n√∫mero entre 1 e 5.")
                    except ValueError:
                        print("Por favor, digite um n√∫mero v√°lido.")

                # Registra feedback PERMANENTEMENTE
                self.record_persistent_feedback(question, answer, docs_used, rating)
                session_queries += 1

                # Resposta motivacional
                if rating < 3:
                    print("\nüîÑ Obrigado! Mem√≥ria atualizada para melhorar.")
                elif rating == 3:
                    print("\nüëç Obrigado! Continuarei aprendendo com a mem√≥ria.")
                else:
                    print("\nüéâ √ìtimo! Mem√≥ria refor√ßada com feedback positivo.")

            except KeyboardInterrupt:
                print("\n\n‚èπÔ∏è  Programa interrompido.")
                self.show_session_summary(session_queries)
                break
            except Exception as e:
                print(f"\n‚ùå Erro: {e}")

    def show_session_summary(self, session_queries):
        """Mostra resumo da sess√£o com estat√≠sticas de mem√≥ria."""
        print("\nüìä RESUMO DA SESS√ÉO:")
        print("="*40)
        print(f"üî¢ Consultas nesta sess√£o: {session_queries}")
        print(f"üìà Total na mem√≥ria: {len(self.query_history)}")
        print(f"üíæ Documentos treinados: {len(self.document_scores)}")

        if self.query_history:
            # Estat√≠sticas da sess√£o
            if session_queries > 0:
                recent_ratings = [q['rating'] for q in self.query_history[-session_queries:]]
                avg_session = sum(recent_ratings) / len(recent_ratings)
                print(f"‚≠ê Nota m√©dia da sess√£o: {avg_session:.1f}/5")

            # Estat√≠sticas gerais da mem√≥ria
            all_ratings = [q['rating'] for q in self.query_history]
            avg_all = sum(all_ratings) / len(all_ratings)
            print(f"üß† M√©dia geral da mem√≥ria: {avg_all:.1f}/5")

            # Melhores documentos
            best_docs = self.get_best_documents(3)
            if best_docs:
                print("\nüèÜ Documentos mais bem avaliados:")
                for doc_id, score in best_docs:
                    title = self.metadata[int(doc_id)]['title']
                    print(f"   - {title}: {score:.1f}/5")

        print("\nüíæ Toda sua avalia√ß√£o foi salva permanentemente!")
        print("üîÑ Na pr√≥xima execu√ß√£o, o sistema lembrar√° de tudo!")
        print("\nüëã Obrigado por treinar o sistema!")

def main():
    """Fun√ß√£o principal."""
    print("üçé RAG COM MEM√ìRIA PERSISTENTE PARA MACBOOK")
    print("Sistema que aprende e LEMBRA para sempre\n")

    try:
        # Inicializa sistema
        rag = SmartRAGWithMemory()

        # Carrega sistema
        if not rag.load_system():
            print("\nüí° Execute primeiro o treinamento:")
            print("   python 1_rag_trainer.py")
            sys.exit(1)

        # Inicia modo interativo com mem√≥ria
        rag.interactive_memory_mode()

    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Programa cancelado.")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
